{"version":3,"sources":["upload.js"],"names":["define","types","objects","arrays","Xhr","filer","upload","params","initDataSettings","o","type","chunkedUpload","data","initXHRData","formData","file","files","multipart","paramName","headers","mixin","contentRange","FormData","blob","append","name","each","index","uploadName","encodeURI","contentType","getUploadedBytes","jqXHR","range","getResponseHeader","parts","split","upperBytesPos","length","parseInt","BitrateTimer","this","timestamp","Date","now","getTime","loaded","bitrate","getBitrate","interval","timeDiff","options","testOnly","uploadedBytes","fs","size","ub","mcs","maxChunkSize","slice","blobSlice","dfd","Deferred","promise","error","i18n","_getXHRPromise","context","currentLoaded","_progress","call","chunkSize","$","ajax","done","result","textStatus","progress","lengthComputable","total","resolveWith","fail","errorThrown","rejectWith","abort","xoptions","undefined","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","message","toString","key","value","replace","form","serializeArray","add","e","isDefaultPrevented","fileupload","process","submit","processData","cache","Blob","prototype","webkitSlice","mozSlice","apply","arguments","request","url","_bitrateTimer","jqXhr"],"mappings":"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","file":"../upload.js","sourcesContent":["define([\r\n\t\"skylark-langx/types\",\r\n\t\"skylark-langx/objects\",\r\n\t\"skylark-langx/arrays\",\r\n\t\"skylark-langx/Xhr\",\r\n\t\"./filer\"\r\n],function(types, objects, arrays, Xhr, filer){\r\n    function upload(params) {\r\n        var xoptions = objects.mixin({\r\n            contentRange: null, //\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function(message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    objects.each(context, function(key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function(form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function(e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function() {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        }, params);\r\n\r\n        var blobSlice = function() {\r\n                var slice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n  \t            return slice.apply(this, arguments);\r\n            },\r\n            ajax = function(data) {\r\n                return Xhr.request(data.url, data);\r\n            };\r\n\r\n        function initDataSettings(o) {\r\n            o.type = o.type || \"POST\";\r\n\r\n            if (!chunkedUpload(o, true)) {\r\n                if (!o.data) {\r\n                    initXHRData(o);\r\n                }\r\n                //initProgressListener(o);\r\n            }\r\n        }\r\n\r\n        function initXHRData(o) {\r\n            var that = this,\r\n                formData,\r\n                file = o.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = o.multipart,\r\n                paramName = types.type(o.paramName) === 'array' ?\r\n                o.paramName[0] : o.paramName;\r\n\r\n            o.headers = objects.mixin({}, o.headers);\r\n            if (o.contentRange) {\r\n                o.headers['Content-Range'] = o.contentRange;\r\n            }\r\n            if (!multipart) {\r\n                o.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n                o.contentType = file.type || 'application/octet-stream';\r\n                o.data = o.blob || file;\r\n            } else {\r\n                formData = new FormData();\r\n                if (o.blob) {\r\n                    formData.append(paramName, o.blob, file.name);\r\n                } else {\r\n                    objects.each(o.files, function(index, file) {\r\n                        // This check allows the tests to run with\r\n                        // dummy objects:\r\n                        formData.append(\r\n                            (types.type(o.paramName) === 'array' &&\r\n                                o.paramName[index]) || paramName,\r\n                            file,\r\n                            file.uploadName || file.name\r\n                        );\r\n                    });\r\n                }\r\n                o.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            o.blob = null;\r\n        }\r\n\r\n        function getTotal(files) {\r\n            var total = 0;\r\n            objects.each(files, function(index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        }\r\n\r\n        function getUploadedBytes(jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        }\r\n\r\n        function initProgressObject(obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                objects.mixin(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        }\r\n\r\n        function BitrateTimer() {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function(now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        }\r\n\r\n        function chunkedUpload(options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = blobSlice,\r\n                dfd = new Deferred(),\r\n                promise = dfd.promise,\r\n                jqXHR,\r\n                upload;\r\n            if (!(slice && (ub || mcs < fs)) ||\r\n                options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context, [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function() {\r\n                // Clone the options object for each chunk upload:\r\n                var o = objects.mixin({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                //initProgressListener(o);\r\n                jqXHR = $.ajax(o).done(function(result, textStatus, jqXHR) {\r\n                        ub = getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            dfd.progress({\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            });\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        //that._trigger('chunkdone', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context, [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function(jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        //that._trigger('chunkfail', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context, [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            //this._enhancePromise(promise);\r\n            promise.abort = function() {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        }\r\n\r\n        initDataSettings(xoptions);\r\n\r\n        xoptions._bitrateTimer = new BitrateTimer();\r\n\r\n        var jqXhr = chunkedUpload(xoptions) || ajax(xoptions);\r\n\r\n        jqXhr.options = xoptions;\r\n\r\n        return jqXhr;\r\n    }\r\n\r\n\treturn filer.upload = upload;\t\r\n})"]}