{"version":3,"sources":["skylark-storages-diskfs.js"],"names":["define","skylark","diskfs","attach","downlad","data","name","window","navigator","msSaveBlob","types","isString","dataURItoBlob","a","document","createElement","Blob","URL","createObjectURL","href","setAttribute","dispatchEvent","CustomEvent","Deferred","read","readFile","file","params","d","reader","FileReader","onload","evt","resolve","target","result","onerror","e","code","error","alert","asArrayBuffer","readAsArrayBuffer","asDataUrl","readAsDataURL","asText","readAsText","promise","fileInput","maxFileSize","select","directory","multiple","fileSelected","picked","input","selectFiles","pickedFiles","i","length","size","splice","type","style","position","left","top","opacity","body","appendChild","onchange","entries","webkitEntries","webentry","all","then","files","Array","prototype","slice","call","value","webkitdirectory","click","objects","arrays","Xhr","upload","xoptions","mixin","contentRange","paramName","undefined","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","multipart","maxChunkSize","uploadedBytes","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","i18n","message","context","this","toString","each","key","replace","formData","form","serializeArray","add","isDefaultPrevented","$","fileupload","process","done","submit","processData","contentType","cache","blobSlice","webkitSlice","mozSlice","apply","arguments","ajax","request","url","initXHRData","o","headers","FormData","blob","append","index","uploadName","encodeURI","chunkedUpload","options","testOnly","jqXHR","fs","ub","mcs","dfd","_getXHRPromise","currentLoaded","_progress","loaded","chunkSize","textStatus","range","getResponseHeader","parts","split","upperBytesPos","parseInt","getUploadedBytes","progress","lengthComputable","total","resolveWith","fail","errorThrown","rejectWith","abort","_bitrateTimer","timestamp","Date","now","getTime","bitrate","getBitrate","interval","timeDiff","jqXhr","concat","one","entry","path","onError","reject","isFile","relativePath","isDirectory","dirReader","createReader","readEntries","catch","map","main"],"mappings":"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","file":"../skylark-storages-diskfs.js","sourcesContent":["define('skylark-storages-diskfs/diskfs',[\r\n    \"skylark-langx/skylark\"\r\n], function(skylark) {\r\n\r\n    function dataURLtoBlob(dataurl) {\r\n        var arr = dataurl.split(','),\r\n            mime = arr[0].match(/:(.*?);/)[1],\r\n            bstr = atob(arr[1]),\r\n            n = bstr.length,\r\n            u8arr = new Uint8Array(n);\r\n        while (n--) {\r\n            u8arr[n] = bstr.charCodeAt(n);\r\n        }\r\n        return new Blob([u8arr], { type: mime });\r\n    }\r\n\r\n\r\n    var diskfs = function() {\r\n        return diskfs;\r\n    };\r\n\r\n    return skylark.attach(\"storages.diskfs\", diskfs);\r\n});\ndefine('skylark-storages-diskfs/download',[\r\n    \"./diskfs\"\r\n],function(diskfs){\r\n\r\n    function downloadFile(data, name) {\r\n        if (window.navigator.msSaveBlob) {\r\n            if (types.isString(data)) {\r\n                data = dataURItoBlob(data);\r\n            }\r\n            window.navigator.msSaveBlob(data, name);\r\n        } else {\r\n            var a = document.createElement('a');\r\n            if (data instanceof Blob) {\r\n                data = URL.createObjectURL(data);\r\n            }\r\n            a.href = data;\r\n            a.setAttribute('download', name || 'noname');\r\n            a.dispatchEvent(new CustomEvent('click'));\r\n        }\r\n    }\r\n\r\n    return diskfs.downlad = downloadFile;\r\n\r\n});\r\n\ndefine('skylark-storages-diskfs/read',[\r\n    \"skylark-langx/Deferred\",\r\n    \"./diskfs\"\r\n],function(Deferred, diskfs){\r\n\r\n    function readFile(file, params) {\r\n        params = params || {};\r\n        var d = new Deferred,\r\n            reader = new FileReader();\r\n\r\n        reader.onload = function(evt) {\r\n            d.resolve(evt.target.result);\r\n        };\r\n        reader.onerror = function(e) {\r\n            var code = e.target.error.code;\r\n            if (code === 2) {\r\n                alert('please don\\'t open this page using protocol fill:///');\r\n            } else {\r\n                alert('error code: ' + code);\r\n            }\r\n        };\r\n\r\n        if (params.asArrayBuffer) {\r\n            reader.readAsArrayBuffer(file);\r\n        } else if (params.asDataUrl) {\r\n            reader.readAsDataURL(file);\r\n        } else if (params.asText) {\r\n            reader.readAsText(file);\r\n        } else {\r\n            reader.readAsArrayBuffer(file);\r\n        }\r\n\r\n        return d.promise;\r\n    }\r\n\r\n    return diskfs.read = diskfs.readFile = readFile;\r\n    \r\n});\r\n\ndefine('skylark-storages-diskfs/select',[\r\n    \"./diskfs\"\r\n],function(diskfs){\r\n    var fileInput,\r\n        fileInputForm,\r\n        fileSelected,\r\n        maxFileSize = 1 / 0;\r\n\r\n    function select(params) {\r\n        params = params || {};\r\n        var directory = params.directory || false,\r\n            multiple = params.multiple || false,\r\n            fileSelected = params.picked;\r\n        if (!fileInput) {\r\n            var input = fileInput = document.createElement(\"input\");\r\n\r\n            function selectFiles(pickedFiles) {\r\n                for (var i = pickedFiles.length; i--;) {\r\n                    if (pickedFiles[i].size > maxFileSize) {\r\n                        pickedFiles.splice(i, 1);\r\n                    }\r\n                }\r\n                fileSelected(pickedFiles);\r\n            }\r\n\r\n            input.type = \"file\";\r\n            input.style.position = \"fixed\";\r\n            input.style.left = 0;\r\n            input.style.top = 0;\r\n            input.style.opacity = .001;\r\n            document.body.appendChild(input);\r\n\r\n            input.onchange = function(e) {\r\n                var entries = e.target.webkitEntries || e.target.entries;\r\n\r\n                if (entries && entries.length) {\r\n                    webentry.all(entries).then(function(files) {\r\n                        selectFiles(files);\r\n                    });\r\n                } else {\r\n                    selectFiles(Array.prototype.slice.call(e.target.files));\r\n                }\r\n                // reset to \"\", so selecting the same file next time still trigger the change handler\r\n                input.value = \"\";\r\n            };\r\n        }\r\n        fileInput.multiple = multiple;\r\n        fileInput.webkitdirectory = directory;\r\n        fileInput.click();\r\n    }\r\n\r\n    return diskfs.select = select;\r\n});\r\n\r\n\ndefine('skylark-storages-diskfs/upload',[\r\n\t\"skylark-langx/types\",\r\n\t\"skylark-langx/objects\",\r\n\t\"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n\t\"skylark-langx/Xhr\",\r\n\t\"./diskfs\"\r\n],function(types, objects, arrays, Deferred,Xhr, diskfs){\r\n\r\n    function upload(params) {\r\n        var xoptions = objects.mixin({\r\n            contentRange: null, //\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function(message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    objects.each(context, function(key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function(form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function(e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function() {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        }, params);\r\n\r\n        var blobSlice = function() {\r\n                var slice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n  \t            return slice.apply(this, arguments);\r\n            },\r\n            ajax = function(data) {\r\n                return Xhr.request(data.url, data);\r\n            };\r\n\r\n        function initDataSettings(o) {\r\n            o.type = o.type || \"POST\";\r\n\r\n            if (!chunkedUpload(o, true)) {\r\n                if (!o.data) {\r\n                    initXHRData(o);\r\n                }\r\n                //initProgressListener(o);\r\n            }\r\n        }\r\n\r\n        function initXHRData(o) {\r\n            var that = this,\r\n                formData,\r\n                file = o.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = o.multipart,\r\n                paramName = types.type(o.paramName) === 'array' ?\r\n                o.paramName[0] : o.paramName;\r\n\r\n            o.headers = objects.mixin({}, o.headers);\r\n            if (o.contentRange) {\r\n                o.headers['Content-Range'] = o.contentRange;\r\n            }\r\n            if (!multipart) {\r\n                o.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n                o.contentType = file.type || 'application/octet-stream';\r\n                o.data = o.blob || file;\r\n            } else {\r\n                formData = new FormData();\r\n                if (o.blob) {\r\n                    formData.append(paramName, o.blob, file.name);\r\n                } else {\r\n                    objects.each(o.files, function(index, file) {\r\n                        // This check allows the tests to run with\r\n                        // dummy objects:\r\n                        formData.append(\r\n                            (types.type(o.paramName) === 'array' &&\r\n                                o.paramName[index]) || paramName,\r\n                            file,\r\n                            file.uploadName || file.name\r\n                        );\r\n                    });\r\n                }\r\n                o.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            o.blob = null;\r\n        }\r\n\r\n        function getTotal(files) {\r\n            var total = 0;\r\n            objects.each(files, function(index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        }\r\n\r\n        function getUploadedBytes(jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        }\r\n\r\n        function initProgressObject(obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                objects.mixin(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        }\r\n\r\n        function BitrateTimer() {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function(now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        }\r\n\r\n        function chunkedUpload(options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = blobSlice,\r\n                dfd = new Deferred(),\r\n                promise = dfd.promise,\r\n                jqXHR,\r\n                upload;\r\n            if (!(slice && (ub || mcs < fs)) ||\r\n                options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context, [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function() {\r\n                // Clone the options object for each chunk upload:\r\n                var o = objects.mixin({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                //initProgressListener(o);\r\n                jqXHR = ajax(o).done(function(result, textStatus, jqXHR) {\r\n                        ub = getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            dfd.progress({\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            });\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        //that._trigger('chunkdone', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context, [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function(jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        //that._trigger('chunkfail', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context, [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            //this._enhancePromise(promise);\r\n            promise.abort = function() {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        }\r\n\r\n        initDataSettings(xoptions);\r\n\r\n        xoptions._bitrateTimer = new BitrateTimer();\r\n\r\n        var jqXhr = chunkedUpload(xoptions) || ajax(xoptions);\r\n\r\n        jqXhr.options = xoptions;\r\n\r\n        return jqXhr;\r\n    }\r\n\r\n\treturn diskfs.upload = upload;\t\r\n});\n define('skylark-storages-diskfs/webentry',[\r\n    \"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n    \"./diskfs\"\r\n],function(arrays,Deferred, diskfs){\r\n    var concat = Array.prototype.concat;\r\n    var webentry = (function() {\r\n        function one(entry, path) {\r\n            var d = new Deferred(),\r\n                onError = function(e) {\r\n                    d.reject(e);\r\n                };\r\n\r\n            path = path || '';\r\n            if (entry.isFile) {\r\n                entry.file(function(file) {\r\n                    file.relativePath = path;\r\n                    d.resolve(file);\r\n                }, onError);\r\n            } else if (entry.isDirectory) {\r\n                var dirReader = entry.createReader();\r\n                dirReader.readEntries(function(entries) {\r\n                    all(\r\n                        entries,\r\n                        path + entry.name + '/'\r\n                    ).then(function(files) {\r\n                        d.resolve(files);\r\n                    }).catch(onError);\r\n                }, onError);\r\n            } else {\r\n                // Return an empy list for file system items\r\n                // other than files or directories:\r\n                d.resolve([]);\r\n            }\r\n            return d.promise;\r\n        }\r\n\r\n        function all(entries, path) {\r\n            return Deferred.all(\r\n                arrays.map(entries, function(entry) {\r\n                    return one(entry, path);\r\n                })\r\n            ).then(function() {\r\n                return concat.apply([], arguments);\r\n            });\r\n        }\r\n\r\n        return {\r\n            one: one,\r\n            all: all\r\n        };\r\n    })();\r\n\r\n    return diskfs.webentry = webentry;\r\n});\ndefine('skylark-storages-diskfs/main',[\r\n\t\"./diskfs\",\r\n\t\"./download\",\r\n\t\"./read\",\r\n\t\"./select\",\r\n\t\"./upload\",\r\n\t\"./webentry\"\r\n],function(diskfs){\r\n\treturn diskfs;\r\n});\ndefine('skylark-storages-diskfs', ['skylark-storages-diskfs/main'], function (main) { return main; });\n\n"]}